// include "List.aes"
payable contract HashTimeLock = 

  record state = {
    contracts : map(bytes(32), lock_contract) }

  record lock_contract = {
    input_amount : int,
    output_amount : int,
    expiration : int,
    hash_lock : bytes(32),
    status: string,
    sender : address,
    receiver : address,
    output_network : string,
    output_address : string}

  datatype event =
    Withdraw(indexed bytes(32), indexed address, indexed address, string)
    | Refund(indexed bytes(32), indexed address, indexed address, string)
    | New_contract(indexed bytes(32), indexed address, indexed address, string)

  function withdrawable(id : bytes(32), secret : bytes(32)) =
    let temp_contract: lock_contract = state.contracts[id]
    require(temp_contract.status == "ACTIVE", "SWAP_NOT_ACTIVE")
    require(temp_contract.expiration > Chain.timestamp, "INVALID_TIME")
    require(temp_contract.hash_lock == Crypto.sha256(secret), "INVALID_SECRET")

  function refundable(id : bytes(32)) =
    let temp_contract: lock_contract = state.contracts[id]
    require(temp_contract.status == "ACTIVE", "SWAP_NOT_ACTIVE")
    require(Chain.timestamp >= temp_contract.expiration, "INVALID_TIME")
    require(temp_contract.sender == Call.caller, "INVALID_SENDER")

  public payable stateful entrypoint new_contract(output_amount : int,
    expiration : int, hash_lock : bytes(32),
    receiver : address, output_network : string, output_address : string) : lock_contract =
    let sender : address = Call.caller
    let input_amount : int = Call.value
    

    let packed_string : string = String.concat(String.concat(String.concat(Address.to_str(sender), 
      Address.to_str(receiver)), String.concat(Int.to_str(input_amount),
       Bytes.to_str(hash_lock))), Int.to_str(expiration))

    let id : bytes(32) = Crypto.sha256(packed_string)

    let new_contract : lock_contract = { 
      input_amount = input_amount,
      output_amount = output_amount,
      expiration = expiration,
      hash_lock = hash_lock,
      status = "ACTIVE",
      sender = sender,
      receiver = receiver,
      output_network = output_network,
      output_address = output_address }

    require(expiration > Chain.timestamp, "INVALID_TIME")
    require(input_amount > 0, "INVALID_AMOUNT")

    put(state{
      contracts[id] = new_contract })

    let bundle_string : string = String.concat(String.concat(output_network, output_address),
     String.concat(String.concat(Int.to_str(input_amount), Int.to_str(output_amount)),
     String.concat(Int.to_str(expiration), Bytes.to_str(hash_lock))))

    //all parameters that ARE NOT indexed, are packed in the string
    Chain.event(New_contract(id, sender, receiver, bundle_string ))

    state.contracts[id]

  public stateful entrypoint withdraw(id : bytes(32), secret: bytes(32)) : bool =
    withdrawable(id, secret)

    let bundle_string : string = String.concat(Bytes.to_str(secret),
     Bytes.to_str(state.contracts[id].hash_lock))

    put(state{
      contracts[id].status = "WITHDRAWN" })
    Chain.spend(state.contracts[id].receiver, state.contracts[id].input_amount)

    //all parameters that ARE NOT indexed, are packed in the string
    Chain.event(Withdraw(id, state.contracts[id].sender,
     state.contracts[id].receiver, bundle_string ))
    true

  public stateful entrypoint refund(id : bytes(32)) : bool =
    refundable(id)

    put(state{
      contracts[id].status = "REFUNDED" })
    Chain.spend(state.contracts[id].sender, state.contracts[id].input_amount)
    
    //all parameters that ARE NOT indexed, are packed in the string
    Chain.event(Refund(id, state.contracts[id].sender, state.contracts[id].receiver, 
      Bytes.to_str(state.contracts[id].hash_lock)))
    true

  public entrypoint get_contract(id : bytes(32)) : lock_contract =
    state.contracts[id] 

  public entrypoint contract_exists(id : bytes(32)) : bool =
    state.contracts[id].status != "invalid"

  public stateful entrypoint dummy_func(hl, id) : lock_contract =

    // let new_contract : lock_contract = { 
    //   input_amount = 534534534,
    //   output_amount = 34543534,
    //   expiration = 5939679548,
    //   hash_lock = hl,
    //   status = "ACTIVE",
    //   sender = ak_n1qctXxqgrWw46kBuTKSVDSCPixxomX5tWh42wFCspBUwcDJ8,
    //   receiver = ak_2mwRmUeYmfuW93ti9HMSUJzCk1EYcQEfikVSzgo6k2VghsWhgU,
    //   output_network = "TRX",
    //   output_address = "0x9cc7a534cf742cdb9ee16fbf6b5f48a09e485c52" }
    
    // put(state{
    //   contracts[id] = new_contract })

    // withdraw(id, hl)

    new_contract(34543534, 1773661036226, hl, ak_n1qctXxqgrWw46kBuTKSVDSCPixxomX5tWh42wFCspBUwcDJ8, "TRX", "0x9cc7a534cf742cdb9ee16fbf6b5f48a09e485c52")

    state.contracts[id]

  public entrypoint get_one_status(id : bytes(32)) : string =
    let temp_contract : lock_contract = state.contracts[id]
    if(temp_contract.status == "ACTIVE" &&
        temp_contract.expiration < Chain.timestamp)
      "EXPIRED"
    else
      temp_contract.status

  // public entrypoint get_many_status(ids : list(bytes(32))) : list(string) =
  //   List.map((id) => getOneStatus(id), ids)

  public entrypoint  init() ={ 
    contracts = {} }

contract HashTimeLock = 

  record state = {
    contracts : map(bytes(32), lock_contract) }

  record lock_contract = {
    input_amount : int,
    output_amount : int,
    expiration : int,
    hash_lock : bytes(32),
    status: string,
    sender : address,
    receiver : address,
    output_network : string,
    output_address : string}

// events still not working as they should
// datatype event =
//  Withdraw(bytes(32), bytes(32), bytes(32))
//  | Refund(bytes(32), bytes(32), address)
//  | New_contract(int, int, int)

  function withdrawable(id : bytes(32), secret : bytes(32)) =
    let temp_contract: lock_contract = state.contracts[id]
    require(temp_contract.status == "active", "SWAP_NOT_ACTIVE")
    require(temp_contract.expiration > Chain.timestamp, "INVALID_TIME")
    require(temp_contract.hash_lock == Crypto.sha256(secret), "INVALID_SECRET")

  function refundable(id : bytes(32)) =
    let temp_contract: lock_contract = state.contracts[id]
    require(temp_contract.status == "active", "SWAP_NOT_ACTIVE")
    require(Chain.timestamp >= temp_contract.expiration, "INVALID_TIME")
    require(temp_contract.sender == Call.caller, "INVALID_SENDER")

  public entrypoint new_contract(output_amount : int, expiration : int, hash_lock : bytes(32),
    receiver : address, output_network : string, output_address : string) =

    let sender : string = "pesho"
    let input_amount : int = 5
    //let bundle :  = ("nasko", 1, "stamat")
    //let sender : address = Call.caller
    //let input_amount : int = Call.value

    //let sender_str = sender.to_str
    //let bundle1 : string = String.concat(sender_str, "nasko")

    require(expiration > Chain.timestamp, "INVALID_TIME")
    require(input_amount > 0, "INVALID_AMOUNT")

    //let id : bytes(32) = Crypto.sha256()
    

  public entrypoint  init() ={ 
    contracts = {} }
